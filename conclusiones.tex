\chapter{CONCLUSIONES}\label{chap:conclusion}
\vskip 3.0ex

En este trabajo se desarrolla un método de compresión de grafos no dirigidos y poco densos, basado en clustering de cliques maximales, usando estructuras de compactas. Se logra llegar a una representación comprimida que permite responder consultas básicas como listado de vecinos de un nodo y reconstrucción del grafo, y otras consultas novedosas como obtener el listado de cliques maximales o saber si dos nodos son vecinos, todo sin tener que descomprimir el grafo.

El nivel de compresión, medido en BPE, es bastante competitivo al estado del arte, siendo superado solo por las dos versiones evaluadas de k2tree, ambas contando con una reciente implementación eficiente para obtener vecinos, considerando listas de adyacencia para grafos no dirigidos, realizada directamente por la autora. Comparado con los otros algoritmos, el resultado en compresión es bastante mejor, sobre todo comparado con WebGraph. Los mejores BPE se logran con los grafos \texttt{coPapersDBLP} (0,76) y \texttt{coPapersCiteseer} (0,48), los cuales presentan los índices de clusterización más altos, muy pocos cliques comparado con la cantidad de nodos, y la mayoría de dichos cliques con al menos 100 nodos.

Para el tiempo de acceso aleatorio, medido como los segundos por arco que toma recuperar vecinos para un millón de nodos, en varios casos se logran mejores resultados que ambos algoritmos de k2tree, pero no logra superar a AD ni menos a WebGraph, que mantiene total predominancia en este ámbito. Analizando junto al resultado en BPE, se puede apreciar que la propuesta se mantiene competitiva, siempre en la zona media de la comparación. El mejor balance lo logran los grafos \texttt{marknewman-condmat}, \texttt{dblp-2010}, \texttt{dblp-2011}, y \texttt{snap-dblp}, todos los cuales poseen una cantidad similar entre vértices y cliques maximales. Mención especial \texttt{snap-amazon}, que contiene más del doble de cliques que vértices, y también logra un buen balance.

Para el tiempo de reconstrucción secuencial del grafo, la estructura propuesta presenta su menor desempeño. En todos los casos, alguna versión de k2tree logra una respuesta más rápida, del orden de 4 veces mejor. Se destaca que para los grafos \texttt{marknewman-astro}, \texttt{marknewman-condmat} y \texttt{dblp-2010}, el método logra mejor tiempo que WebGraph.

En cuanto al tiempo de recuperar el listado de cliques maximales, la propuesta es mucho mas rápida que el algoritmo \textbf{Quick Cliques}\footnote{\url{https://github.com/darrenstrash/quick-cliques}} y si bien es cierto que para generar la estructura se debe generar dicho listado previamente, una vez comprimido el grafo se puede volver a obtener en un tiempo menor. Especial atención a los grafos \texttt{coPapersDBLP} y \texttt{coPapersCiteseer}, que son los grafos con menor BPE, y recuperan el listado de cliques más de 10 veces más rápido. Además esta operación no es fácil de realizar usando las otras técnicas de compresión comparadas.

Esta propuesta además posee la consulta que permite saber si dos vértices son vecinos, sin tener que generar los listados de adyacencia de ninguno de los dos, directamente de la estructura, y en un tiempo  $O((M_{1} + M_{2}) \cdot bpu_{p})$ cuando hay bytes en las particiones, o $O(M_{1} + M_{2})$ si no los hay, siendo $M_{1}$ la cantidad de particiones que contienen al vértice 1, y $M_{2}$ al vértice 2. 

Con esto en consideración, una buena aplicación para el método propuesto son máquinas donde el espacio para guardar el grafo sea limitado, como dispositivos móviles con poca RAM y espacio en disco, donde se pueden almacenar los grafos gracias al buen nivel de compresión, y además permite responder consultas sin ocupar espacio en la descompresión, pagando un tiempo algo mayor.

Como trabajo futuro, se puede explorar cómo mejorar los tiempos de acceso de esta estructura, por ejemplo investigar nuevas funciones de ranking en la heurística de clusterización. Otra opción es explotar el potencial de paralelismo que posee la estructura compacta, ya que cada partición se puede acceder de manera simultánea, y cada comparación de bytes dentro de las particiones se puede optimizar usando instrucciones paralelas como SIMD\footnote{SIMD: Single Instruction, Multiple Data. Una Instrucción, múltiples datos.}.

