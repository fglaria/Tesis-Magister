\chapter{CONCLUSIONES}\label{chap:conclusion}
\vskip 3.0ex

%En progreso...

Este trabajo se enfoca en desarrollar un método de compresión de grafos basado en clustering de cliques maximales, apuntado a grafos no dirigidos. Se logra llegar a una estructura compacta final que comprime un grafo y permite responder consultas sin tener que descomprimir para ello.

Entrando en detalle, el nivel de compresión logrado, medido en BPE, es mejor al estado del arte (ver Tabla~\ref{table:BPEcomp}), superando en todos los casos estudiados a los otros algoritmos. Incluso puntualmente para el caso de los grafos \texttt{coPapersDBLP} y \texttt{coPapersCiteseer}, los cuales poseen los coeficiente de clusterización (0,80 y 0,83) y transitividad (0,65 y 0,77) más altos (ver Tabla~\ref{table:gafros3}, se logran los BPE de 0,80 y 0,52 respectivamente, lo que es muy eficiente. Si bien este resultado en la compresión es muy positivo, es necesario reconocer el efecto que conlleva en los tiempos de acceso 

El tiempo de acceso aleatorio, medido usando el Algoritmo~\ref{alg:neighbors} recuperando vecinos para un millón de nodos, en varios casos se logran mejores resultados que k2tree con orden del grafo original, pero no usando BFS, donde solo para el grafo \texttt{dblp-2010} logra un tiempo similar, en los demás es mayor. Más lejos aún comparando con AD o Webgraph, donde en el mejor de los casos los tiempos logrados con respecto a AD son del orden del doble, para \texttt{marknewman-condmat}, \texttt{dblp-2010} y \texttt{coPapersDBLP} (ver Tabla~\ref{table:timesRandom}).

Para el tiempo de reconstrucción secuencial, medido usando el Algoritmo~\ref{alg:sequential}, solo para los grafos pequeños \texttt{marknewman-astro} y \texttt{marknewman-condmat} se obtienen resultados mejores con respecto a WebGraph, en ambos casos casi la mitad. Pero en general, tampoco se logra un tiempo mejor a los algoritmos en comparación, y para los grafos \texttt{coPapersDBLP} y \texttt{coPapersCiteseer} que presentan la mejor compresión, se obtienen tiempos mucho más altos (ver Tabla~\ref{table:timesSecuencial}).

Con esto en consideración, una buena aplicación para el método propuesto son dispositivos donde el espacio para guardar el grafo sea limitado, como dispositivos móviles con poca RAM y espacio en disco, donde se pueden almacenar los grafos usando una compresión muy eficiente, y que permitirá responder consultas sin ocupar mucho espacio extra y en un tiempo algo mayor. Esto no es menor, ya que sin esta opción de compresión, y pese a su costo en tiempos de acceso, no se podría almacenar los grafos en dichos dispositivos de otra manera.

Además, esta estructura compacta permite obtener el listado de cliques maximales directamente de ella, sin tener que descomprimir el grafo completo, y pese a que se necesita generar este listado antes de su construcción, una vez comprimido permite listar los cliques de manera rápida (ver Tabla~\ref{table:constructTimes}). Esto, junto con el nivel de compresión ya mencionado, sirve para trabajar con dispositivos de memoria acotada en variadas aplicaciones biológicas \cite{eblen2012maximum, hendrix2010theoretical}, entre otras \cite{bomze1999maximum}.

Como trabajo futuro, se puede explorar cómo mejorar los tiempos de acceso de esta estructura, por ejemplo encontrar nuevas funciones de ranking en la heurística de  clusterización para mejorar la relación entre compresión y tiempos de acceso. Otra opción es explotar el potencial de paralelismo que posee la estructura compacta, ya que cada partición se puede acceder de manera simultánea, y cada comparación de bytes dentro de las particiones se puede optimizar usando instrucciones paralelas, como SIMD\footnote{SIMD: Single Instruction, Multiple Data. Una Instrucción, múltiples datos.}.
